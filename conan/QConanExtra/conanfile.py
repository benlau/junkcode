from conans.model import Generator
from conans import ConanFile,tools
import os
import json
import re

def load_qconanextra_json(folder):
    path = os.path.join(folder, "qconanextra.json")
    content = {}
    try:
        with open(path, 'r') as myfile:
            data = myfile.read()
        content = json.loads(data);
    except IOError:
        pass
    except Exception as e:
        print(e)
        pass
    return content

def flatten(input):
    if type(input) is not list:
        return [input]
    
    ret = []

    for item in input:
        if type(item) is not list:
            ret.append(item)
            continue
        if len(item) == 0:
            continue
        ret = ret + flatten(item)
    
    return ret

def obtain_value(deps_build_info, field):
    res = []

    for dep_name, dep_cpp_info in deps_build_info.dependencies:

        deps = qconanextra_deps(dep_cpp_info)

        content = load_qconanextra_json(deps.rootpath)
        values = flatten([content.get(field, [])])
        res += values
    
    return  flatten(res)

def obtain_qml_import_path(deps_build_info):
    qml_import_path = []

    for dep_name, dep_cpp_info in deps_build_info.dependencies:

        deps = qconanextra_deps(dep_cpp_info)

        content = load_qconanextra_json(deps.rootpath)
        paths = flatten([content.get("qml_import_path", [])])
        paths = [os.path.join(deps.rootpath, p) for p in paths]
        qml_import_path += paths

    qml_import_path = flatten(qml_import_path)
    
    return qml_import_path

class qconanextra_deps(object):
    def __init__(self, deps_cpp_info):
        self.include_paths = ",\n".join('"%s"' % p.replace("\\", "/")
                                        for p in deps_cpp_info.include_paths)
        self.lib_paths = ",\n".join('"%s"' % p.replace("\\", "/")
                                    for p in deps_cpp_info.lib_paths)
        self.bin_paths = ",\n".join('"%s"' % p.replace("\\", "/")
                                    for p in deps_cpp_info.bin_paths)
        self.libs = ", ".join('"%s"' % p for p in deps_cpp_info.libs)
        self.defines = ", ".join('"%s"' % p for p in deps_cpp_info.defines)
        self.cppflags = ", ".join('"%s"' % p for p in deps_cpp_info.cppflags)
        self.cflags = ", ".join('"%s"' % p for p in deps_cpp_info.cflags)
        self.sharedlinkflags = ", ".join('"%s"' % p for p in deps_cpp_info.sharedlinkflags)
        self.exelinkflags = ", ".join('"%s"' % p for p in deps_cpp_info.exelinkflags)

        self.rootpath = "%s" % deps_cpp_info.rootpath.replace("\\", "/")

class qconanextra_header(Generator):
    @property
    def filename(self):
        return "qconanextra.h"
    
    @property 
    def content(self):
        sections = ["//Generated by qconanextra", 
                    "#pragma once", 
                    "#include <QtGlobal>", 
                    "#include <QQmlExtensionPlugin>",
                    "#include <QMap>",
                    "#include <QString>",
                    ""]
        
        initCode = ["#define QCONAN_EXTRA_INIT() { "]
        
        for dep_name, dep_cpp_info in self.deps_build_info.dependencies:

            deps = qconanextra_deps(dep_cpp_info)
            content = load_qconanextra_json(deps.rootpath)
            resources = flatten([content.get("resource", [])])
            for r in resources:
                initCode.append('    Q_INIT_RESOURCE(%s); ' % r)

            plugins = flatten([content.get("plugin", [])])
            for p in plugins:
                initCode.append('    Q_IMPORT_PLUGIN(%s);' % p)                

        
        ## import_static_qml_plugin
        
        import_static_qml_plugin = obtain_value(self.deps_build_info, "import_static_qml_plugin")
        regexp = re.compile(r"[a-zA-Z0-9]+:[a-zA-Z0-9]+")
        import_static_qml_plugin = filter(lambda x: regexp.match(x), import_static_qml_plugin)
        
        initCode.append("    QMap<QString,QString> import_static_qml_plugin;");

        for plugin in import_static_qml_plugin:
            token = plugin.split(":")
            initCode.append("    import_static_qml_plugin[\"%s\"] = \"%s\";" % (token[0], token[1]) );
            
        initCode.append("    foreach(QObject* plugin, QPluginLoader::staticInstances()) {");
        initCode.append("       QString pluginName = plugin->metaObject()->className();");
        initCode.append("       if (!import_static_qml_plugin.contains(pluginName)) continue;");
        initCode.append("       QQmlExtensionPlugin* qmlPlugin = qobject_cast<QQmlExtensionPlugin*>(plugin);");
        initCode.append("       if (!qmlPlugin) continue;");
        initCode.append("       qmlPlugin->registerTypes(import_static_qml_plugin[pluginName].toUtf8().constData());");
        initCode.append("    }");

        initCode.append("")
        
#        sections.append("#define QCONAN_EXTRA_INIT(engine) {")
#        
#        qml_import_path = obtain_qml_import_path(self.deps_build_info)
#        for path in qml_import_path:
#            sections.append("    engine.addImportPath(\"%s\");" % path)
#        
#        sections.append("}")
#        
#        sections.append("")

        initCode.append("}")
    
        sections.append("\\\n".join(initCode))

        return "\n".join(sections)
    
class qconanextra_qmake(Generator):
    @property
    def filename(self):
        return "qconanextra.pri"

    @property
    def content(self):
        deps = qconanextra_deps(self.deps_build_info)

        sections = ["#Generated by QConanExtra package"]  

        qml_import_path = obtain_qml_import_path(self.deps_build_info)

        template = ("QML_IMPORT_PATH += {qml_import_path}\n")
        sections.append(template.format(qml_import_path = " ".join(qml_import_path)))
        return "\n".join(sections)

class qconanextra_package(ConanFile):
    name = "qconanextra"
    version = "0.1"
    url = ""
    license = "MIT"

    def build(self):
        pass

    def package_info(self):
        self.cpp_info.includedirs = []
        self.cpp_info.libdirs = []
        self.cpp_info.bindirs = []
